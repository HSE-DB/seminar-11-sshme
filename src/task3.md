## Задание 3

1. Создайте таблицу с большим количеством данных:
    ```sql
    CREATE TABLE test_cluster AS 
    SELECT 
        generate_series(1,1000000) as id,
        CASE WHEN random() < 0.5 THEN 'A' ELSE 'B' END as category,
        md5(random()::text) as data;
    ```

2. Создайте индекс:
    ```sql
    CREATE INDEX test_cluster_cat_idx ON test_cluster(category);
    ```

3. Измерьте производительность до кластеризации:
    ```sql
    EXPLAIN ANALYZE
    SELECT * FROM test_cluster WHERE category = 'A';
    ```
    
    *План выполнения:*
    ```
    Bitmap Heap Scan on test_cluster  (cost=59.17..7696.73 rows=5000 width=68) (actual time=11.417..81.628 rows=500303 loops=1)
      Recheck Cond: (category = 'A'::text)
      Heap Blocks: exact=8334
      ->  Bitmap Index Scan on test_cluster_cat_idx  (cost=0.00..57.92 rows=5000 width=0) (actual time=10.126..10.126 rows=500303 loops=1)
            Index Cond: (category = 'A'::text)
    Planning Time: 0.324 ms
    Execution Time: 96.826 ms
    ```
    
    *Объясните результат:*
    Запрос использует Bitmap Heap Scan для поиска всех строк с category = 'A'. Индекс находит 500303 строки, которые распределены по 8334 блокам таблицы. Данные не упорядочены по категории, поэтому требуется чтение большого количества блоков в случайном порядке, что приводит к относительно высокому времени выполнения (96.826 ms).

4. Выполните кластеризацию:
    ```sql
    CLUSTER test_cluster USING test_cluster_cat_idx;
    ```
    
    *Результат:*
    ```
    CLUSTER
    ```
    Кластеризация успешно выполнена. Таблица физически переупорядочена по индексу test_cluster_cat_idx, что означает, что все строки с одинаковым значением category теперь расположены рядом друг с другом на диске.

5. Измерьте производительность после кластеризации:
    ```sql
    EXPLAIN ANALYZE
    SELECT * FROM test_cluster WHERE category = 'A';
    ```
    
    *План выполнения:*
    ```
    Bitmap Heap Scan on test_cluster  (cost=59.17..7668.56 rows=5000 width=68) (actual time=9.830..100.981 rows=500303 loops=1)
      Recheck Cond: (category = 'A'::text)
      Heap Blocks: exact=4170
      ->  Bitmap Index Scan on test_cluster_cat_idx  (cost=0.00..57.92 rows=5000 width=0) (actual time=9.298..9.298 rows=500303 loops=1)
            Index Cond: (category = 'A'::text)
    Planning Time: 0.347 ms
    Execution Time: 151.903 ms
    ```
    
    *Объясните результат:*
    После кластеризации количество блоков, которые нужно прочитать, значительно уменьшилось с 8334 до 4170 (почти в 2 раза). Это происходит потому, что все строки с category = 'A' теперь расположены компактно в последовательных блоках. Однако время выполнения увеличилось до 151.903 ms, что может быть связано с особенностями кэширования или другими факторами системы. Важно отметить, что кластеризация улучшила эффективность использования дискового пространства (меньше блоков для чтения).

6. Сравните производительность до и после кластеризации:
    
    *Сравнение:*
    
    **До кластеризации:**
    - Execution Time: 96.826 ms
    - Heap Blocks: exact=8334
    - Данные распределены случайно по таблице
    
    **После кластеризации:**
    - Execution Time: 151.903 ms
    - Heap Blocks: exact=4170 (уменьшение в 2 раза)
    - Данные упорядочены по категории
    
    **Анализ:**
    
    Кластеризация достигла своей основной цели - уменьшила количество блоков, которые нужно прочитать, с 8334 до 4170 (улучшение в 2 раза). Это означает, что данные стали более компактными и последовательными на диске.
    
    Увеличение времени выполнения может быть связано с:
    1. Особенностями кэширования операционной системы и PostgreSQL
    2. Изменением паттерна доступа к данным (последовательное vs случайное чтение)
    3. Нагрузкой на систему в момент выполнения
    
    В реальных сценариях кластеризация особенно полезна для:
    - Запросов, которые читают большие диапазоны данных по ключу кластеризации
    - Уменьшения количества случайных обращений к диску
    - Улучшения производительности при работе с данными, которые часто запрашиваются вместе
    
    Важно помнить, что кластеризация требует периодического обновления (повторного выполнения команды CLUSTER), так как при вставке новых данных порядок может нарушаться.